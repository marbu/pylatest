# -*- coding: utf8 -*-

"""
ReStructuredText directives for test steps, actions and metadata.

Note that binding between name of directive (as used in rst file) and rst
directive class which implements it is defined in pylatest.xdocutils.client
module.
"""

# Copyright (C) 2015 martin.bukatovic@gmail.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


from docutils import nodes
from docutils.parsers import rst

from pylatest.xdocutils.transforms import TestStepsTableTransform
from pylatest.xdocutils.transforms import TestStepsPlainTransform
from pylatest.xdocutils.transforms import TestMetadataTableTransform
from pylatest.xdocutils.transforms import TestMetadataPlainTransform
import pylatest.xdocutils.nodes


class TestActionDirective(rst.Directive):
    """
    Base class with implementation of ``test_step`` and ``test_result`` rst
    directives.

    Creates pending element (which contain parsed content of the directive)
    so that rst transformation is able to build final rst node tree structure
    later.
    """

    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = False
    has_content = True
    option_spec = {
        'include': str,
        }

    # Class of rst transformation for this directive, which creates final
    # representation of all test steps directives in rst node tree.
    # Since this is base class which is not direcly usable, transform class
    # should be defined in each subclass.
    transform_class = None

    def run(self):
        # each pylatest directive in the rst document has mandatory action id
        # (starts from 1), so there is either just one or no pylatest directive
        # with action_id == 1
        # note:
        # action is couple of test step and result with the same action_id
        if len(self.arguments) == 0:
            action_id = None
        else:
            action_id = int(self.arguments[0])
        # first of all, parse text content of this directive
        # into anonymous node element (can't be used directly in the tree)
        node = nodes.Element()
        # include HACK: link to the referred test case
        # TODO: use a proper referece (nested parse?)
        # TODO: the final solutions is a working include though
        if 'include' in self.options:
            ref_tc, ref_action = str(self.options['include']).split(":", 2)
            text_content = "See {0}, action {1}".format(ref_tc, ref_action)
            node += nodes.paragraph(text=text_content)
        else:
            self.state.nested_parse(self.content, self.content_offset, node)
        # create new pending node, which:
        #  - holds actual data (parsed content of the directive)
        #  - references transform class which is concerned with this node.
        #  - name of the directive (test_step or test_result)
        pending = nodes.pending(self.transform_class)
        # add content into pending node
        pending.details['nodes'] = node
        pending.details['action_id'] = action_id
        pending.details['action_name'] = self.name
        # since pylatest transformation will process all pylatest pending nodes
        # at once, we register only 1st test step pending node, and
        # this also means that the result generated by pylatest transform
        # will be located in the place of this first test step directive
        if action_id == 1 and self.name == "test_step":
            # without this, transformer wouldn't know about this pending node
            self.state_machine.document.note_pending(pending)
        # and finally return the pending node as the only result
        return [pending]


class TestActionTableDirective(TestActionDirective):
    """
    Implementation of ``test_step`` and ``test_result`` directives for
    direct consumption (transformation will generate proper table from
    data stored in pending elements), eg. for html output.
    """

    transform_class = TestStepsTableTransform


class TestActionTableDirectiveAutoId(TestActionTableDirective):
    """
    Implementation of ``test_step`` and ``test_result`` directives for
    direct consumption, with optional argument for action id.
    """

    required_arguments = 0
    optional_arguments = 1


class TestActionPlainDirective(TestActionDirective):
    """
    Implementation of ``test_step`` and ``test_result`` directives for
    further processing, eg. checking particular part of resulting document.
    """

    transform_class = TestStepsPlainTransform


class TestActionPlainDirectiveAutoId(TestActionPlainDirective):
    """
    Implementation of ``test_step`` and ``test_result`` directives for
    direct consumption, with optional argument for action id.
    """

    required_arguments = 0
    optional_arguments = 1


class TestMetadataDirective(rst.Directive):
    """
    Base class with implementation of ``test_metadata`` directive.

    Create pending element (which contain content of the directive)
    so that rst transformation is able to build final rst node tree structure
    later.
    """

    required_arguments = 2
    optional_arguments = 0
    final_argument_whitespace = True
    has_content = False

    # Class of rst transformation for this directive, which creates final
    # representation of all metadata directives in rst node tree.
    # Since this is base class which is not direcly usable, transform class
    # should be defined in each subclass.
    transform_class = None

    def run(self):
        # TODO: error checking
        meta_name, meta_value = self.arguments
        # create new pending node, which will:
        #  - hold metadata
        #  - reference transform class which is concerned with this node
        pending = nodes.pending(self.transform_class)
        # add content into pending node
        pending.details['meta_name'] = meta_name
        pending.details['meta_value'] = meta_value
        # check if there is already some metadata pending node in the
        # document tree
        # TODO: this is not very smart/effective, fix it later
        meta_pending_registered = False
        for node in self.state_machine.document.traverse(nodes.pending):
            if 'meta_name' in node.details:
                meta_pending_registered = True
                break
        # since transformation will process all pending nodes
        # at once, we register only 1st test metadata pending node, and
        # this also means that the result generated by pylatest transform
        # will be located in the place of this first test step directive
        if not meta_pending_registered:
            # without this, transformer wouldn't know about this pending node
            self.state_machine.document.note_pending(pending)
        # and finally return the pending node as the only result
        return [pending]


class TestMetadataTableDirective(TestMetadataDirective):
    """
    Implementation of ``test_metadata`` directive for
    direct consumption (transformation will generate proper table from
    data stored in pending elements), eg. for html output.
    """

    transform_class = TestMetadataTableTransform


class TestMetadataPlainDirective(TestMetadataDirective):
    """
    Implementation of ``test_metadata`` directive for
    further processing, eg. checking particular part of resulting document.
    """

    transform_class = TestMetadataPlainTransform


class RequirementPlainDirective(rst.Directive):
    """
    Implementation of ``requirement`` rst directive.
    """

    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True
    has_content = True
    option_spec = {
        'priority': str,
        }

    def run(self):
        self.assert_has_content()
        req_id = self.arguments[0]
        node = pylatest.xdocutils.nodes.requirement_node()
        node.attributes['req_id'] = req_id
        if 'priority' in self.options:
            node.attributes['priority'] = self.options['priority']
        self.state.nested_parse(self.content, self.content_offset, node)
        return [node]


class RequirementSectionDirective(RequirementPlainDirective):
    """
    Implementation of ``requirement`` rst directive for human friendly HTML,
    all content is placed into a section with req_id in it's header.
    """

    def run(self):
        self.assert_has_content()
        section_node = nodes.section()
        # header of the section
        req_id = self.arguments[0]
        title = "Requirement {0}".format(req_id)
        section_node += nodes.title(text=title)
        # see docutils.nodes.Element docstring for description of both
        # 'ids' and 'names' attributes (necessary for table of contents)
        # attr ids - list of unique keys
        section_node.attributes['ids'] = [nodes.make_id(title)]
        # attr names - list of element names, generated from title or content
        section_node.attributes['names'] = [nodes.fully_normalize_name(title)]
        # priority paragraph (if priority is specified)
        if 'priority' in self.options:
            text = "Priority: {0}".format(self.options['priority'])
            prio_node = nodes.paragraph(text=text)
            section_node += prio_node
        # and a paragraph with all content of the directive
        tmp_node = nodes.Element()
        self.state.nested_parse(self.content, self.content_offset, tmp_node)
        for content_node in tmp_node:
            section_node += content_node
        return [section_node]
